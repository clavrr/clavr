"""
Response Personalizer Capability

Adapts agent responses to user preferences and context.
"""
import re
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

# Use shared logger
from src.utils.logger import setup_logger

# Import centralized constants
from src.agents.constants import DOMAIN_EMOJIS

logger = setup_logger(__name__)

class DetailLevel(str, Enum):
    MINIMAL = "minimal"
    STANDARD = "standard"
    COMPREHENSIVE = "comprehensive"

class ResponseFormat(str, Enum):
    CONCISE = "concise"
    DETAILED = "detailed"
    STRUCTURED = "structured"
    CONVERSATIONAL = "conversational"
    TECHNICAL = "technical"

@dataclass
class UserPreferences:
    """User preferences for response generation"""
    user_id: int
    preferred_format: ResponseFormat = ResponseFormat.CONVERSATIONAL
    preferred_detail_level: DetailLevel = DetailLevel.STANDARD
    include_timestamps: bool = True
    include_statistics: bool = False
    use_emojis: bool = True
    max_items_shown: int = 5
    group_by_domain: bool = True
    updated_at: datetime = datetime.now()

class ResponsePersonalizer:
    """
    Personalizes agent responses based on user preferences and context.
    """
    
    # Default templates for different formats
    TEMPLATES = {
        'concise': "{main_answer}",
        'detailed': "{main_answer}\n\n{context}\n\n{details}",
        'structured': "## Result\n{main_answer}\n\n### Details\n{details_list}",
        'conversational': "{greeting} {main_answer} {follow_up}",
    }
    
    def __init__(self):
        self.user_preferences: Dict[int, UserPreferences] = {}
        self.interaction_history: Dict[int, List[Dict]] = {}
        self.stats = {
            'responses_personalized': 0,
            'users_profiled': 0,
            'avg_engagement_score': 0.0
        }
        self.format_handlers = self._initialize_templates()
        
    def personalize_response(
        self,
        response_text: str,
        user_id: int = 1,  # Default for single-user assumption
        query: str = "",
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """MAIN ENTRY POINT: Personalize a raw response string"""
        self.stats['responses_personalized'] += 1
        
        # Get preferences
        prefs = self.get_user_preferences(user_id) or UserPreferences(user_id=user_id)
        self.user_preferences[user_id] = prefs  # Cache if new
        self.stats['users_profiled'] = len(self.user_preferences)
        
        # Base personalization
        personalized = response_text
        
        # Apply formatting based on preference
        if prefs.use_emojis:
            personalized = self._add_emojis(personalized)
            
        # Structure by domain if applicable (requires structured data in context)
        response_data = context.get('data', {}) if context else {}
        if prefs.group_by_domain and response_data:
            personalized = self._group_by_domain(personalized, response_data)
        
        # Add suggested actions
        if response_data:
             personalized = self._add_suggested_actions(personalized, response_data, query)
             
        # Record interaction
        self._store_interaction(user_id, query, personalized, response_data)
        
        return personalized

    def _add_emojis(self, text: str) -> str:
        """Add emojis to text intelligently using centralized mapping."""
        processed = text
        
        for word, emoji in DOMAIN_EMOJIS.items():
            # Word boundary check, only add if emoji not already present
            pattern = re.compile(r'\b' + re.escape(word) + r'\b', re.IGNORECASE)
            if emoji not in processed:
                processed = pattern.sub(f"{emoji} {word}", processed)
        
        return processed

    def _group_by_domain(self, text: str, data: Dict[str, Any]) -> str:
        """Organize response by domain if data exists"""
        # If the text is already structured, don't mess with it too much.
        # This is a lightweight enhancement.
        sections = []
        domains = ['email', 'calendar', 'tasks', 'notion']
        
        has_domain_data = any(domain in data for domain in domains)
        if not has_domain_data:
            return text
            
        # If the response is generated by LLM, it might not follow our sections.
        # We append a structured summary if missing.
        sections.append(text)
        sections.append("\n---")
        
        for domain in domains:
            if domain in data and data[domain]:
                sections.append(f"**{domain.title()}**")
                items = data[domain]
                if isinstance(items, list):
                    for item in items[:3]: # Limit to 3 in summary
                        sections.append(f"- {str(item)}")
                    if len(items) > 3:
                        sections.append(f"*(and {len(items)-3} more)*")
        
        return "\n".join(sections)

    def _add_suggested_actions(self, text: str, data: Dict[str, Any], query: str) -> str:
        """Append suggested actions"""
        actions = []
        
        # Email actions
        if 'email' in data or 'mail' in query.lower():
            actions.append("ğŸ“§ Reply to sender")
            actions.append("ğŸ” Find related emails")
            
        # Calendar actions
        if 'calendar' in data or 'schedule' in query.lower():
            actions.append("ğŸ“… Reschedule")
            actions.append("ğŸ”” Add reminder")
            
        if not actions:
            return text
            
        actions_text = "\n\n**Suggested Actions:**\n" + "\n".join([f"- {a}" for a in actions[:3]])
        return text + actions_text

    def _store_interaction(
        self,
        user_id: int,
        query: str,
        response: str,
        response_data: Dict[str, Any]
    ) -> None:
        """Store interaction for future learning"""
        if user_id not in self.interaction_history:
            self.interaction_history[user_id] = []
        
        self.interaction_history[user_id].append({
            'query': query,
            'response': response,
            'timestamp': datetime.now()
        })
        # Keep last 100
        if len(self.interaction_history[user_id]) > 100:
             self.interaction_history[user_id].pop(0)

    def _initialize_templates(self) -> Dict[str, Any]:
        """Initialize format handlers for different response styles."""
        return {
            'concise': self._format_concise,
            'detailed': self._format_detailed,
            'structured': self._format_structured,
            'conversational': self._format_conversational,
            'technical': self._format_technical,
        }
    
    def _format_concise(self, main_answer: str, **kwargs) -> str:
        """Format response in minimal style."""
        return main_answer.strip()
    
    def _format_detailed(self, main_answer: str, context: str = "", details: str = "", **kwargs) -> str:
        """Format response with full context and details."""
        parts = [main_answer]
        if context:
            parts.append(f"\n\n**Context:**\n{context}")
        if details:
            parts.append(f"\n\n**Details:**\n{details}")
        return "".join(parts)
    
    def _format_structured(self, main_answer: str, details_list: list = None, **kwargs) -> str:
        """Format response in markdown structured style."""
        parts = [f"## Result\n{main_answer}"]
        if details_list:
            parts.append("\n\n### Details")
            for item in details_list[:10]:
                parts.append(f"\n- {item}")
        return "".join(parts)
    
    def _format_conversational(self, main_answer: str, greeting: str = "", follow_up: str = "", **kwargs) -> str:
        """Format response in friendly conversational style."""
        parts = []
        if greeting:
            parts.append(f"{greeting} ")
        parts.append(main_answer)
        if follow_up:
            parts.append(f" {follow_up}")
        return "".join(parts)
    
    def _format_technical(self, main_answer: str, code_blocks: list = None, references: list = None, **kwargs) -> str:
        """Format response for technical content."""
        parts = [main_answer]
        if code_blocks:
            for block in code_blocks[:5]:
                parts.append(f"\n\n```\n{block}\n```")
        if references:
            parts.append("\n\n**References:**")
            for ref in references[:5]:
                parts.append(f"\n- {ref}")
        return "".join(parts)

    def get_user_preferences(self, user_id: int) -> Optional[UserPreferences]:
        return self.user_preferences.get(user_id)
    
    def set_user_preferences(self, user_id: int, prefs: UserPreferences):
        self.user_preferences[user_id] = prefs

